<template>
	<div class="page">
	  <scroll id="scrollId"
		if="{{readMode !== 'nostalgic'}}"
		style="position: absolute; width: 432px; height: {{scrollHeight}}px; top: {{verticalMargin}}px;"
		scroll-y="{{true}}"
		scroll-top="{{scrollTopValue}}"
		@scroll="onScroll"
		@scrolltop="onScrollTop"
		@scrollbottom="onScrollBottom"
		@click="onTxtClick"
		onlongpress="onTxtLongPress"
		@touchstart="onTouchStart"
		@touchmove="onTouchMove"
		@touchend="onTouchEnd"
		bounces="{{(isAtChapterStart || isAtChapterEnd) && (chapterSwitchStyle == 'boundary')}}"
		>
		<div id="contentContainer" style="position: absolute; width:432px; flex-direction: column;">
            <div if="{{chapterSwitchStyle == 'button' && isAtChapterStart && !showSetting && currentChapterIndexInAll > 0}}" style="width: 100%; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center; background-image: url('/common/images/背景.png'); background-size: cover; background-position: center;" @click="goToPrevChapter">
				<text static style="color: #aaa; font-size: 28px; font-weight: bold;">上一章</text>
			</div>
		  <div id="page1" style="flex-direction: column; width: 100%; flex-shrink: 0;">
			<text style="width: 432px; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">{{ page1.text }}</text>
		  </div>
		  <div id="page2" if="{{page2}}" style="flex-direction: column; width: 100%; flex-shrink: 0;">
			<text style="width: 432px; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; ">{{ page2.text }}</text>
		  </div>
            <div if="{{chapterSwitchStyle == 'button' && isAtChapterEnd && !showSetting && currentChapterIndexInAll < totalChapters - 1}}" style="width: 100%; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center; background-image: url('/common/images/背景.png'); background-size: cover; background-position: center;" @click="goToNextChapter">
				<text static style="color: #aaa; font-size: 28px; font-weight: bold;">下一章</text>
			</div>
		</div>
  </scroll>
  <div show="{{chapterSwitchStyle == 'overlay' && isAtChapterStart && !showSetting && currentChapterIndexInAll > 0}}" style="position: absolute; left: 0px; top: 0px; width: 432px; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center; background-image: url('/common/images/背景.png'); background-size: cover; background-position: center;" @click="goToPrevChapter">
    <text static style="color: #FFFFFF; font-size: 28px; font-weight: bold;">上一章</text>
  </div>
  <div show="{{chapterSwitchStyle == 'overlay' && isAtChapterEnd && !showSetting && currentChapterIndexInAll < totalChapters - 1}}" style="position: absolute; left: 0px; bottom: 0px; width: 432px; height: {{chapterSwitchHeight}}px; justify-content: center; align-items: center; background-image: url('/common/images/背景.png'); background-size: cover; background-position: center;" @click="goToNextChapter">
    <text static style="color: #FFFFFF; font-size: 28px; font-weight: bold;">下一章</text>
  </div>
	  <div if="{{readMode === 'nostalgic'}}" 
		id="nostalgicContainer"
		style="position: absolute; width: 432px; height: {{scrollHeight}}px; top: {{verticalMargin}}px;"
		@click="onNostalgicClick"
		onlongpress="onTxtLongPress">
		<div id="nostalgicContent" style="position: absolute; width:432px; height: {{scrollHeight}}px; flex-direction: column; justify-content: flex-start; pointer-events: none;">
		  <div id="nostalgicPage" style="flex-direction: column; width: 100%; height: 100%; pointer-events: none;">
			<text style="width: 432px; height: {{scrollHeight}}px; text-align: left; color: rgba(255,255,255,{{opacity/100}}); font-size: {{fontSize}}px; font-weight: bold; line-height: {{lineHeight}}px; overflow: hidden; pointer-events: none;">{{ nostalgicPageText }}</text>
		  </div>
		</div>
	  </div>
	  <img show="{{showSetting || (alwaysShowTime && !isNearTopForHd)}}" src="/common/images/hd.png" style="position: absolute;left: 0px;top: 0px;width: 432px;height: 122px;" />
		<img show="{{showSetting}}" src="/common/images/back.png" @click="back" style="position: absolute;left: 38px;top: 24px;width: 82px;height: 82px;"/>
		<img show="{{showSetting}}" src="/common/images/more.png" @click="gotoSetting" style="position: absolute;left: 322px;top: 24px;width: 82px;height: 82px;"/>
		<div show="{{showSetting || (alwaysShowTime && !isNearTopForHd)}}" style="position: absolute; left: 130px; top: 8px; width: 172px; flex-direction: column; align-items: center;">
			<text style="line-height: 24px; font-weight: bold; font-size: 20px; color: rgba(255,255,255,0.6); text-align: center;">
				{{batteryLevel}}
			</text>
			<text style="line-height: 28px; font-weight: bold; font-size: 24px; color: rgba(255,255,255,0.6); text-align: center;">
				{{nowTime}}
			</text>
		</div>
		<marquee if="{{textReaderMarqueeEnabled}}" scrollamount="50"text-offset="25" show="{{showSetting}}" style="position: absolute;left: 130px;top: 58px;width: 172px;line-height: 42px;font-weight:bold;font-size:32px;color:white;text-align:center;">
			{{currentChapterName}}
		</marquee>
		<text else show="{{showSetting}}" style="position: absolute;left: 130px;top: 58px;width: 172px;line-height: 42px;font-weight:bold;font-size:32px;color:white;text-align:center;lines: 1;">
			{{currentChapterName}}
		</text>
		<text if="{{showProgressBar && showProgressBarPercent}}" class="progress-bar-percent" style="bottom: {{progressBarHeight + 1}}px;">{{Math.round(chapterProgress)}}%</text>

		<img show="{{showSetting}}" src="/common/images/bt.png" style="position: absolute;left: 0px;top: 412px;width: 432px;height: 102px;" />
        <img show="{{showSetting}}" src="{{ isKeepScreenOn ? '/common/images/brightness.png' : '/common/images/brightness_off.png' }}" @click="toggleKeepScreenOn" style="position: absolute;left: 38px;top: 408px;width: 82px;height: 82px;"/>
		<div show="{{showSetting}}" style="position: absolute; top: 426px; left: 130px; width: 172px; height: 82px; flex-direction: column; justify-content: flex-start; align-items: center;">
			<text style="line-height: 42px;font-weight:bold;font-size:32px;color:white;text-align:center;">
				{{currentPage}} / {{totalPages}}
			</text>
			<text static style="line-height: 32px;font-weight:bold;font-size:24px;color:rgba(255,255,255,0.6);text-align:center;">
				阅读进度
			</text>
		</div>
        <img show="{{showSetting}}" src="/common/images/add_bookmark.png" @click="addBookmark" @longpress="gotoBookmarks" style="position: absolute;left: 322px;top: 408px;width: 82px;height: 82px;"/>
		
		<div if="{{showProgressBar && !showSetting}}" class="progress-bar-container" style="height: {{progressBarHeight}}px;">
			<progress percent="{{chapterProgress}}" style="left: 35px;width: 362px;color: #E1DDDD;stroke-width: {{progressBarHeight}}px;layer-color: #00000000;"></progress>
		</div>
	</div>
</template>

<script>
	import prompt from '@system.prompt'
	import file from '@system.file'
	import router from '@system.router'
    import storage from '../../common/storage.js'
	import bookStorage from '../../common/bookStorage.js'
	import chapterManager from '../../common/chapterManager.js'
	import brightness from '@system.brightness'
	import app from '@system.app'
	import battery from '@system.battery'

	export default {
	  allSize: 0,
    autoInterval: null,
    cPath: "",
	  private: {
		txtSizePage: 800,
		fontSize: 30,
		lineHeight: 34,
		pageHeigh: 514,
		verticalMargin: 10,
		scrollHeight: 514,
		showSetting: true,
		loadingNext: false,
		loadingPrev: false,
		page1: { text: "加载中...", offset: 0, length: 0 },
		page2: null,
		currentFileOffset: 0,
		opacity: 100,
		swipe: 'column',
		auto: false,
		nowTime: "00:00",
		batteryLevel: "",
		timer: null,
		timeCounter: 0,
		savedScrollOffset: 0,
      	currentScrollTop: 0,
		totalPages: 0,
		currentPage: 0,
		isKeepScreenOn: false,
		currentChapterIndexInAll: 0,
		currentChapterName: "",
		isAtChapterEnd: false,
		isAtChapterStart: false,
		scrollTopValue: 0,
		wait: false,
		longPressTriggered: false,
		saveDataTimeout: null,
		totalChapters: 0,
		teacherScreenEnabled: false,
		clickCount: 0,
		clickTimeout: null,
		chapterProgress: 0,
		showProgressBar: true,
		progressBarHeight: 8,
		showProgressBarPercent: false,
		gestureMode: 'single',
		gestureClickCount: 0,
		gestureClickTimeout: null,
		chapterSwitchHeight: 80,
		chapterSwitchSensitivity: 50,
		swipeSensitivity: 80,
		chapterSwitchStyle: 'overlay',
		
		touchStartY: 0,
		overscrollDistance: 0,
		isTouching: false,
		bounces: false,
		touchStartX: 0,
		touchEndX: 0,
		isInitialized: false,
		longPressTimeout: null,
		isProcessingClick: false,
		autoReadDistance: 100,
        timeFormat: '24h',
		contentHeight: 0,
		preventParagraphSplitting: false,
        preloadChapter: false,
        chapterContentCache: null,
        saveMode: 'exit',
        saveIntervalValue: 10,
		alwaysShowTime: false,
		alwaysShowTimeSensitivity: 50,
		isNearTopForHd: false,
		lastTxtSizePage: 400,
		lastFontSize: 30,
		readMode: 'scroll',
		nostalgicPageText: '',
		nostalgicPageIndex: 0,
		nostalgicPages: [],
		nostalgicFullContent: '',
		nostalgicCharsPerPage: 0,
		textReaderMarqueeEnabled: false
	  },
	  protected: {
		name: '',
		chapterIndex: -1,
		chapterName: ''
	  },
	  updateTime() {
		const date = new Date();
		let hours = date.getHours();
		let minutes = date.getMinutes();
        if (this.timeFormat === '12h') {
            let ampm = hours >= 12 ? '下午' : '上午';
            hours = hours % 12;
            hours = hours ? hours : 12;
            minutes = minutes < 10 ? '0' + minutes : minutes;
            this.nowTime = `${ampm} ${hours}:${minutes}`;
        } else {
            hours = hours < 10 ? '0' + hours : hours;
            minutes = minutes < 10 ? '0' + minutes : minutes;
            this.nowTime = `${hours}:${minutes}`;
        }
	 },
	 updateBatteryStatus() {
		battery.getStatus({
		  success: (data) => {
			let level = Math.round(data.level * 100);
			this.batteryLevel = data.charging ? `充电中 ${level}%` : `电量 ${level}%`;
		  }
		})
	  },
	updatePageNumber(){
		this.currentPage = this.currentChapterIndexInAll + 1;
		this.totalPages = this.totalChapters;
	},
	onInit(){
		this.updateTime();
		this.updateBatteryStatus();
		this.timer = setInterval(() => { 
			this.updateTime(); 
			this.timeCounter++;
			if (this.timeCounter >= 60) {
				this.updateBatteryStatus();
				this.timeCounter = 0;
			}
		}, 1000);
		globalThis.isKeepScreenOn = this.isKeepScreenOn;
	},
	async onShow(){
		await this.loadSettings();
		
		
		const settingsChanged = this.isInitialized && 
			(this.lastTxtSizePage !== this.txtSizePage || this.lastFontSize !== this.fontSize);
		
		this.updateBatteryStatus();
		if (typeof globalThis.isKeepScreenOn !== 'undefined') {
			if (this.isKeepScreenOn !== globalThis.isKeepScreenOn) {
				this.isKeepScreenOn = globalThis.isKeepScreenOn;
				brightness.setKeepScreenOn({ keepScreenOn: this.isKeepScreenOn });
				prompt.showToast({ message: this.isKeepScreenOn ? '已开启屏幕常亮' : '已关闭屏幕常亮' });
			}
		}
		storage.get({
			key: 'EBOOK_TEACHER_SCREEN_ENABLED',
			success: (data) => {
				this.teacherScreenEnabled = data === 'true';
			}
		});
		const isChapterJump = globalThis.justJumpedFromChapter || globalThis.justJumpedFromBookmark || globalThis.justJumpedFromPageNumber;
        if (!this.isInitialized || isChapterJump || settingsChanged) {
            if(globalThis.justJumpedFromChapter) {
			    this.chapterIndex = globalThis.newChapterIndex;
			    this.chapterName = globalThis.newChapterName;
                delete globalThis.newChapterIndex;
			    delete globalThis.newChapterName;
            }
			await this.loadBook();
            this.isInitialized = true;
			
			this.lastTxtSizePage = this.txtSizePage;
			this.lastFontSize = this.fontSize;
        }
	},
	async loadSettings() {
		const getSetting = (key, defaultValue) => new Promise(resolve => {
			storage.get({
				key,
				success: data => resolve(data !== null && data !== '' ? data : defaultValue),
				fail: () => resolve(defaultValue)
			});
		});
	
		const settingsConfig = [
			{ key: 'EBOOK_TXTSZPAGE', prop: 'txtSizePage', type: 'int', default: 400 },
			{ key: 'EBOOK_VERTICAL_MARGIN', prop: 'verticalMargin', type: 'int', default: 10 },
			{ key: 'EBOOK_FONT', prop: 'fontSize', type: 'int', default: 30 },
			{ key: 'EBOOK_OPACITY', prop: 'opacity', type: 'int', default: 100 },
			{ key: 'EBOOK_SWIPE', prop: 'swipe', type: 'string', default: 'column' },
			{ key: 'EBOOK_AUTO', prop: 'auto', type: 'json', default: null },
			{ key: 'EBOOK_SHOW_PROGRESS_BAR', prop: 'showProgressBar', type: 'bool', default: true },
			{ key: 'EBOOK_PROGRESS_BAR_HEIGHT', prop: 'progressBarHeight', type: 'int', default: 8 },
			{ key: 'EBOOK_SHOW_PROGRESS_BAR_PERCENT', prop: 'showProgressBarPercent', type: 'bool', default: false },
			{ key: 'EBOOK_GESTURE', prop: 'gestureMode', type: 'string', default: 'single' },
			{ key: 'EBOOK_CHAPTER_SWITCH_HEIGHT', prop: 'chapterSwitchHeight', type: 'int', default: 80 },
			{ key: 'EBOOK_CHAPTER_SWITCH_SENSITIVITY', prop: 'chapterSwitchSensitivity', type: 'int', default: 50 },
			{ key: 'EBOOK_SWIPE_SENSITIVITY', prop: 'swipeSensitivity', type: 'int', default: 80 },
			{ key: 'EBOOK_CHAPTER_SWITCH_STYLE', prop: 'chapterSwitchStyle', type: 'string', default: 'overlay' },
			{ key: 'EBOOK_AUTO_READ_DISTANCE', prop: 'autoReadDistance', type: 'int', default: 100 },
			{ key: 'EBOOK_PREVENT_PARAGRAPH_SPLITTING', prop: 'preventParagraphSplitting', type: 'bool', default: false },
			{ key: 'EBOOK_PRELOAD_CHAPTER', prop: 'preloadChapter', type: 'bool', default: false },
			{ key: 'EBOOK_TIME_FORMAT', prop: 'timeFormat', type: 'string', default: '24h' },
            { key: 'EBOOK_PROGRESS_SAVE_MODE', prop: 'saveMode', type: 'string', default: 'exit' },
			{ key: 'EBOOK_PROGRESS_SAVE_INTERVAL', prop: 'saveIntervalValue', type: 'int', default: 10 },
			{ key: 'EBOOK_ALWAYS_SHOW_TIME', prop: 'alwaysShowTime', type: 'bool', default: false },
			{ key: 'EBOOK_ALWAYS_SHOW_TIME_SENSITIVITY', prop: 'alwaysShowTimeSensitivity', type: 'int', default: 200 },
			{ key: 'EBOOK_READ_MODE', prop: 'readMode', type: 'string', default: 'scroll' },
			{ key: 'EBOOK_TEXT_READER_MARQUEE_ENABLED', prop: 'textReaderMarqueeEnabled', type: 'bool', default: false }
		];
	
		const promises = settingsConfig.map(s => getSetting(s.key, s.default));
		const results = await Promise.all(promises);
	
		results.forEach((data, i) => {
			const config = settingsConfig[i];
			let value = data;
			
			switch (config.type) {
				case 'int': this[config.prop] = parseInt(value); break;
				case 'bool': this[config.prop] = value === 'true' || value === true; break;
				case 'json': 
					if (value) {
						const parsed = typeof value === 'string' ? JSON.parse(value) : value;
						if(parsed && parsed.enable) this.auto = parsed.speed;
					}
					break;
				default: this[config.prop] = value; break;
			}
		});
	
		this.lineHeight = parseInt((-0.01)*(this.fontSize**2) + 1.62*this.fontSize - 3.23);
		this.updateScrollHeight();
		if (this.readMode === 'nostalgic') {
			this.calculateNostalgicCharsPerPage();
			if (this.nostalgicFullContent) {
				this.splitNostalgicContent();
				this.updateNostalgicPage();
			}
		}
	},
	updateContentHeight() {
		setTimeout(() => {
			this.$element("contentContainer").getBoundingClientRect({
				success: (rect) => {
					this.contentHeight = rect.height;
				}
			});
		}, 50);
	},
	updateScrollHeight() {
		this.scrollHeight = 514 - this.verticalMargin * 2;
		this.pageHeigh = Math.floor(this.scrollHeight/this.lineHeight) * this.lineHeight;
	},
	calculateNostalgicCharsPerPage() {
		const screenWidth = 432;
		const screenHeight = this.scrollHeight;
		
		if (screenHeight <= 0 || this.lineHeight <= 0 || this.fontSize <= 0) {
			this.nostalgicCharsPerPage = 100;
			return;
		}
		
		const linesPerPage = Math.floor(screenHeight / this.lineHeight);
		if (linesPerPage <= 0) {
			this.nostalgicCharsPerPage = 100;
			return;
		}
		
		const charWidth = this.fontSize;
		const charsPerLine = Math.floor(screenWidth / charWidth);
		
		if (charsPerLine <= 0) {
			this.nostalgicCharsPerPage = 100;
			return;
		}
		
		this.nostalgicCharsPerPage = linesPerPage * charsPerLine;
		
		if (this.nostalgicCharsPerPage <= 0) {
			this.nostalgicCharsPerPage = 100;
		}
		if (this.nostalgicCharsPerPage > 10000) {
			this.nostalgicCharsPerPage = 10000;
		}
	},
	async loadBook() {
		try {
			const version = await chapterManager.checkVersion(this.name);
			if (version === 'old') {
				await chapterManager.handleOldVersion(this.name);
				return;
			}
			if (version === 'none') {
				this.page1 = { text: "本书没有内容", offset: 0, length: 0 };
				return;
			}
			this.totalChapters = await chapterManager.getTotalChapters(this.name);
		} catch (e) {
			prompt.showToast({ message: '章节列表加载失败' });
			this.totalChapters = 0;
			return;
		}

		if (this.totalChapters === 0) {
			this.page1 = { text: "本书没有内容", offset: 0, length: 0 };
			return;
		}

		let progress = await bookStorage.get(this.name);
		let chapterToLoadIndex;
		let offsetInChapter = 0;
		let scrollOffset = 0;
		let fromChapterJump = false;
		let shouldScrollToTop = false;
		let fromBookmark = false;

		if (globalThis.justJumpedFromChapter) {
			fromChapterJump = true;
			chapterToLoadIndex = this.chapterIndex;
			this.currentChapterName = this.chapterName;
			offsetInChapter = 0;
			scrollOffset = 0;
			shouldScrollToTop = true;
			globalThis.justJumpedFromChapter = false;
		} else if (globalThis.justJumpedFromPageNumber) {
			chapterToLoadIndex = globalThis.justJumpedChapterIndex !== undefined ? globalThis.justJumpedChapterIndex : progress.chapterIndex;
			offsetInChapter = 0;
			scrollOffset = 0;
			shouldScrollToTop = true;
			globalThis.justJumpedFromPageNumber = false;
			delete globalThis.justJumpedChapterIndex;
		} else if (globalThis.justJumpedFromBookmark) {
			chapterToLoadIndex = globalThis.justJumpedBookmarkChapterIndex !== undefined 
				? globalThis.justJumpedBookmarkChapterIndex 
				: progress.chapterIndex;
			offsetInChapter = progress.offsetInChapter || 0;
			scrollOffset = progress.scrollOffset || 0;
			fromBookmark = true;
			globalThis.justJumpedFromBookmark = false;
			delete globalThis.justJumpedBookmarkChapterIndex;
		} else if (progress.chapterIndex !== null) {
			chapterToLoadIndex = progress.chapterIndex;
			offsetInChapter = progress.offsetInChapter || 0;
			scrollOffset = progress.scrollOffset || 0;
		} else {
			chapterToLoadIndex = 0;
		}

		
		const oldTxtSizePage = progress.txtSizePage || this.txtSizePage;
		const oldFontSize = progress.fontSize || this.fontSize;
		
		
		if (oldTxtSizePage !== this.txtSizePage || oldFontSize !== this.fontSize) {
			const fontSizeRatio = oldFontSize > 0 ? this.fontSize / oldFontSize : 1;
			const txtSizePageRatio = oldTxtSizePage > 0 ? this.txtSizePage / oldTxtSizePage : 1;
			
			if (txtSizePageRatio !== 1 && offsetInChapter > 0) {
				offsetInChapter = Math.floor(offsetInChapter * txtSizePageRatio);
			}
			
			if (fontSizeRatio !== 1 && scrollOffset > 0) {
				scrollOffset = Math.floor(scrollOffset * fontSizeRatio);
			}
		}

     	progress = null;

		let chapterArrayIndex = chapterToLoadIndex;

		if (chapterArrayIndex < 0 || chapterArrayIndex >= this.totalChapters) {
			chapterToLoadIndex = 0;
			chapterArrayIndex = 0;
		}
		
		this.currentFileOffset = offsetInChapter;
		this.savedScrollOffset = scrollOffset;
		this.scrollTopValue = scrollOffset;
		this.currentScrollTop = scrollOffset;
		
		this._shouldScrollToTop = shouldScrollToTop;
		this._fromBookmark = fromBookmark;
		this._bookmarkOffsetInChapter = fromBookmark ? offsetInChapter : null;

		this.loadChapter(chapterArrayIndex, () => {
			if (this.readMode === 'nostalgic') {
				this.wait = false;
				this.loadNostalgicChapter(offsetInChapter);
			} else {
				this.loadInitialSegments();
				
				if (fromChapterJump || shouldScrollToTop) {
					this.isAtChapterStart = shouldScrollToTop;
				} else if (this.currentFileOffset === 0 && this.savedScrollOffset < 10) {
					this.isAtChapterStart = true;
				} else {
					this.isAtChapterStart = false;
				}
				this.isNearTopForHd = this.currentFileOffset === 0 && this.savedScrollOffset < this.alwaysShowTimeSensitivity;
			}
		});
	},
	async loadChapter(chapterIdxInAll, callback) {
		if (chapterIdxInAll < 0 || chapterIdxInAll >= this.totalChapters) {
			if(callback) callback();
			return;
		}

		const chapter = await chapterManager.getChapterByIndex(this.name, chapterIdxInAll);
		if (!chapter) {
			prompt.showToast({ message: '无法加载章节信息' });
			if(callback) callback();
			return;
		}
		
		if (this.page1) {
			this.page1.text = null;
		}
		if (this.page2) {
			this.page2.text = null;
		}
		let oldPage1 = this.page1;
		let oldPage2 = this.page2;
		this.page1 = { text: "", offset: 0, length: 0 };
		this.page2 = null;
		oldPage1 = null;
		oldPage2 = null;
		
		this.isAtChapterStart = false;
		this.isAtChapterEnd = false;
		this.currentChapterIndexInAll = chapterIdxInAll;
		this.currentChapterName = chapter.name;
		this.cPath = `internal://files/books/${this.name}/content/${chapter.index}.txt`;
        this.chapterContentCache = null;

		file.get({
			uri: this.cPath,
			success: (data) => {
				this.allSize = data.length;
				this.updatePageNumber();
                if (this.readMode === 'nostalgic' || (this.preloadChapter && this.allSize > 0)) {
                    file.readArrayBuffer({
                        uri: this.cPath,
                        success: (arrData) => {
                            try {
                                if (!arrData.buffer || arrData.buffer.byteLength === 0) {
                                    this.chapterContentCache = "";
                                } else {
                                    const buffer = new Uint8Array(arrData.buffer);
                                    const chars = [];
                                    for(let i = 0; i < buffer.length; i += 2){
                                      chars.push(String.fromCharCode(buffer[i+1]*256 + buffer[i]));
                                    }
                                    this.chapterContentCache = chars.join('');
                                    if (this.readMode === 'nostalgic') {
                                        this.nostalgicFullContent = this.chapterContentCache;
                                    }
                                }
                            } catch(e) {
                                this.chapterContentCache = null;
                                if (this.readMode === 'nostalgic') {
                                    this.nostalgicFullContent = "";
                                }
                            }
                            if(callback) callback();
                        },
                        fail: () => {
                            this.chapterContentCache = null;
                            if (this.readMode === 'nostalgic') {
                                this.nostalgicFullContent = "";
                            }
                            if(callback) callback();
                        }
                    });
                } else {
				    if(callback) callback();
                }
			},
			fail: (data, code) => {
				this.allSize = 0;
                prompt.showToast({ message: `加载章节失败: ${code}` });
				if(callback) callback();
			}
		});
	},
	loadInitialSegments(){
		var that = this;
		this.wait = true;
		this.readFileText(this.currentFileOffset, function(str, bytesRead){
		  that.page1 = { text: str, offset: that.currentFileOffset, length: bytesRead };
		  that.loadNextSegmentNoScroll();
		  that.updateChapterProgress();
		  that.updateContentHeight();
		});
	},
	loadNextSegmentNoScroll(){
		var that = this;
		let newOffset = that.page1.offset + that.page1.length;
		if(newOffset >= this.allSize) {
			that.isAtChapterEnd = true;
			that.page2 = null;
			that.restoreScrollPosition();
			return;
		}
	
		that.readFileText(newOffset, function(str, bytesRead){
			if(str){
				that.page2 = { text: str, offset: newOffset, length: bytesRead };
			} else {
				that.page2 = null;
			}
			that.restoreScrollPosition();
			that.updateContentHeight();
		});
	},
	restoreScrollPosition() {
		setTimeout(() => {
			
			const shouldScrollToTop = this._shouldScrollToTop || (this.currentFileOffset === 0 && this.savedScrollOffset === 0);
			
			if (shouldScrollToTop) {
				
				this.scrollTopValue = 0;
				this.currentScrollTop = 0;
				this.currentFileOffset = 0;
				this.savedScrollOffset = 0;
				this.finalizeScrollRestore();
			} else {
				
				if (this._fromBookmark && this._bookmarkOffsetInChapter !== null && this._bookmarkOffsetInChapter > 0) {
					
					this.$element("page1").getBoundingClientRect({
						success: (page1Rect) => {
							
							const bookmarkOffset = this._bookmarkOffsetInChapter;
							const page1StartOffset = this.page1.offset;
							const page1EndOffset = page1StartOffset + this.page1.length;
							
							if (bookmarkOffset >= page1StartOffset && bookmarkOffset < page1EndOffset) {
								
								const offsetInPage1 = bookmarkOffset - page1StartOffset;
								const charsInPage1 = offsetInPage1 / 2;
								const avgCharWidth = this.fontSize * 0.6; 
								const charsPerLine = Math.floor(432 / avgCharWidth);
								const linesInPage1 = Math.ceil(charsInPage1 / charsPerLine);
								const heightInPage1 = linesInPage1 * this.lineHeight;
								
								const totalScroll = heightInPage1 + this.savedScrollOffset;
								this.scrollTopValue = Math.max(0, Math.floor(totalScroll));
								this.currentScrollTop = Math.max(0, Math.floor(totalScroll));
							} else if (bookmarkOffset < page1StartOffset) {
								
								this.scrollTopValue = Math.max(0, Math.floor(this.savedScrollOffset));
								this.currentScrollTop = Math.max(0, Math.floor(this.savedScrollOffset));
							} else {
								
								const charsBeforeOffset = bookmarkOffset / 2;
								const avgCharWidth = this.fontSize * 0.6; 
								const charsPerLine = Math.floor(432 / avgCharWidth);
								const linesBeforeOffset = Math.ceil(charsBeforeOffset / charsPerLine);
								const estimatedHeightBefore = linesBeforeOffset * this.lineHeight;
								
								const totalScroll = estimatedHeightBefore + this.savedScrollOffset;
								this.scrollTopValue = Math.max(0, Math.floor(totalScroll));
								this.currentScrollTop = Math.max(0, Math.floor(totalScroll));
							}
							
							this.finalizeScrollRestore();
						},
						fail: () => {
							
							this.scrollTopValue = Math.max(0, Math.floor(this.savedScrollOffset));
							this.currentScrollTop = Math.max(0, Math.floor(this.savedScrollOffset));
							this.finalizeScrollRestore();
						}
					});
				} else {
					
					this.scrollTopValue = Math.max(0, Math.floor(this.savedScrollOffset));
					this.currentScrollTop = Math.max(0, Math.floor(this.savedScrollOffset));
					this.finalizeScrollRestore();
				}
			}
		}, 100); 
	},
	finalizeScrollRestore() {
		this.$element("contentContainer").getBoundingClientRect({
			success: (rect) => {
				this.contentHeight = rect.height;
				this.updateChapterProgress();
				this.wait = false;
				if (this.contentHeight <= this.scrollHeight) {
					this.isAtChapterStart = true;
					this.isAtChapterEnd = true;
				}
				if (this.chapterSwitchStyle === 'overlay') {
					this.showSetting = false;
				}
				
				this._shouldScrollToTop = false;
				this._fromBookmark = false;
				this._bookmarkOffsetInChapter = null;
				this.saveData(true);
			},
			fail: () => {
				this.wait = false;
				this._shouldScrollToTop = false;
				this._fromBookmark = false;
				this._bookmarkOffsetInChapter = null;
			}
		});
	},
	readFileText(readOffset, cb){
		if(readOffset >= this.allSize){ cb('', 0); return; }
        
        if (this.chapterContentCache) {
            const start = readOffset / 2;
            let end = start + this.txtSizePage;
            if (end > this.chapterContentCache.length) {
                end = this.chapterContentCache.length;
            }
            
            let str = this.chapterContentCache.substring(start, end);
            
            if (this.preventParagraphSplitting && end < this.chapterContentCache.length) {
                const lastNewline = str.lastIndexOf('\n');
                if (lastNewline > -1) {
                    str = str.substring(0, lastNewline + 1);
                }
            }
            const bytesRead = str.length * 2;
            cb(str, bytesRead);
            return;
        }

		var length = this.txtSizePage * 2;
		if(readOffset < 0){ length += readOffset; readOffset = 0; }
		if((readOffset + length) >= this.allSize){ length = this.allSize - readOffset; }
		
		file.readArrayBuffer({
		  uri: this.cPath, position: readOffset, length: length,
		  success: (data) => {
			if (!data.buffer || data.buffer.byteLength === 0) {
				cb('', 0);
				return;
			}
			try {
                const buffer = new Uint8Array(data.buffer);
                const chars = [];
				for(let i = 0; i < buffer.length; i += 2){
				  chars.push(String.fromCharCode(buffer[i+1]*256 + buffer[i]));
				}
				let str = chars.join('');
                
                let bytesRead = length;
                if (this.preventParagraphSplitting && (readOffset + length) < this.allSize) {
                    const lastNewline = str.lastIndexOf('\n');
                    if (lastNewline > -1) {
                        str = str.substring(0, lastNewline + 1);
                        bytesRead = str.length * 2;
                    }
                }
				cb(str, bytesRead);
			} catch (e) {
				cb('', 0);
			}
		  },
		  fail: function(){ cb('', 0); }
		});
	},
	onScroll(e){
		if (this.wait) return;

		if (this.isAtChapterEnd && e.scrollY < this.currentScrollTop) {
			this.isAtChapterEnd = false;
		}
		this.currentScrollTop = e.scrollY;
		this.updateChapterProgress();
		this.isAtChapterStart = this.currentFileOffset === 0 && this.currentScrollTop < 10;
		this.isNearTopForHd = this.currentFileOffset === 0 && this.currentScrollTop < this.alwaysShowTimeSensitivity;

		if (this.contentHeight > this.scrollHeight) {
			const isNearBottom = this.currentScrollTop >= (this.contentHeight - this.scrollHeight - this.chapterSwitchSensitivity);
			if (isNearBottom) {
				let lastSeg = this.page2 || this.page1;
				let newOffset = lastSeg.offset + lastSeg.length;
				if(newOffset >= this.allSize) {
					this.isAtChapterEnd = true;
				}
			}
		}
	},
	onScrollTop(){
		if (this.wait) return;
		if (this.currentFileOffset > 0) {
			if(!this.loadingPrev){ this.loadingPrev = true; this.loadPrevSegment(); }
		}
	},
	onScrollBottom(){
		if (this.wait) return;
		if(!this.loadingNext){ this.loadingNext = true; this.loadNextSegment(); }
	},
	loadNextSegment(){
		this.wait = true;
		var that = this;
		let lastSeg = that.page2 || that.page1;
		let newOffset = lastSeg.offset + lastSeg.length;

		if(newOffset >= this.allSize) {
			that.loadingNext = false;
			that.isAtChapterEnd = true;
			that.wait = false;
			return;
		}

		this.readFileText(newOffset, function (str, bytesRead) {
			that.loadingNext = false;
			if(str){
				const nextPageData = { text: str, offset: newOffset, length: bytesRead };
				that.shiftPagesForward(nextPageData);
			} else {
				that.wait = false;
			}
		});
	},
	shiftPagesForward(nextPageData) {
		var that = this;
		const scrollPosBeforeLoad = this.currentScrollTop;
		that.$element("page1").getBoundingClientRect({
			success: function(rect){
				let removedHeight = rect.height;
				
				that.page1 = that.page2;
				that.page2 = nextPageData;
				
				const newScrollPos = scrollPosBeforeLoad - removedHeight + that.lineHeight;
				that.scrollTopValue = Math.max(0, newScrollPos);
				that.currentScrollTop = Math.max(0, newScrollPos);

				that.currentFileOffset = that.page1.offset;
				that.updateChapterProgress();
				that.saveData(true);
				that.wait = false;
				that.updateContentHeight();
			},
			fail: function() {
				that.wait = false;
			}
		});
	},
	loadPrevSegment(){
		this.wait = true;
		var that = this;
		if(that.page1.offset <= 0){
			this.wait = false;
			this.loadingPrev = false;
			return;
		}

		let newOffset = that.page1.offset - this.txtSizePage * 2;
		if(newOffset < 0) newOffset = 0;

		this.readFileText(newOffset, function (str, bytesRead) {
			that.loadingPrev = false;
			if(str){
				const prevPageData = { text: str, offset: newOffset, length: bytesRead };
				
				let oldPage2 = that.page2;
				if (oldPage2) {
					oldPage2.text = null;
				}
				that.page2 = that.page1;
				that.page1 = prevPageData;
				oldPage2 = null;

				that.$element("page1").getBoundingClientRect({
					success: function(rect){
						const newScrollPos = that.currentScrollTop + rect.height;
						that.scrollTopValue = newScrollPos;
						that.currentScrollTop = newScrollPos;
						that.currentFileOffset = that.page1.offset;
						that.updateChapterProgress();
						that.saveData(true);
						that.wait = false;
						that.updateContentHeight();
					},
					fail: function() {
						that.wait = false;
					}
				});
			} else {
				that.wait = false;
			}
		});
	},
	onTouchStart(e) {
		this.isTouching = true;
		this.touchStartY = e.touches[0].clientY;
		this.overscrollDistance = 0;
		if (this.chapterSwitchStyle === 'swipe') {
			this.touchStartX = e.touches[0].clientX;
			this.touchEndX = e.touches[0].clientX;
		}
	},
	onTouchMove(e) {
		if (!this.isTouching) return;

		if (this.chapterSwitchStyle === 'boundary') {
			const currentY = e.touches[0].clientY;
			const deltaY = currentY - this.touchStartY;

			if (this.isAtChapterStart && deltaY > 0) {
				this.overscrollDistance = deltaY;
			} else if (this.isAtChapterEnd && deltaY < 0) {
				this.overscrollDistance = -deltaY;
			} else {
				this.overscrollDistance = 0;
			}
		} else if (this.chapterSwitchStyle === 'swipe') {
			this.touchEndX = e.touches[0].clientX;
		}
	},
	onTouchEnd(e) {
		if (!this.isTouching) return;
		this.isTouching = false;
		
		if (this.chapterSwitchStyle === 'boundary') {
			if (this.overscrollDistance > this.chapterSwitchSensitivity) {
				if (this.isAtChapterStart) {
					this.goToPrevChapter();
				} else if (this.isAtChapterEnd) {
					this.goToNextChapter();
				}
			}
			this.overscrollDistance = 0;
			this.touchStartY = 0;
		} else if (this.chapterSwitchStyle === 'swipe') {
			if (this.touchStartX === 0) return;
			const deltaX = this.touchEndX - this.touchStartX;
			if (Math.abs(deltaX) > this.swipeSensitivity) {
				if (deltaX > 0) {
					this.goToPrevChapter();
				} else {
					this.goToNextChapter();
				}
			}
			this.touchStartX = 0;
			this.touchEndX = 0;
		}
	},
	goToPrevChapter() {
        if (this.wait) return;
        this.wait = true;

        const prevChapterIndex = this.currentChapterIndexInAll - 1;
        if (prevChapterIndex < 0) {
            prompt.showToast({ message: '已是第一章' });
            this.wait = false;
            return;
        }
        
        
        this.isAtChapterEnd = false;
        this.currentFileOffset = 0;
        this.savedScrollOffset = 0;
        this.scrollTopValue = 0;
        this.currentScrollTop = 0;

        this.loadChapter(prevChapterIndex, () => {
            if (this.readMode === 'nostalgic') {
                this.loadNostalgicChapter(-1);
            } else {
                this.page1 = { text: "加载中...", offset: 0, length: 0 };
                this.page2 = null;
                this.loadInitialSegments();
                this.isAtChapterStart = true;
                this.isNearTopForHd = true;
            }
            this.chapterProgress = 0;
            this.saveData(true);
        });
    },
    loadEndAndScroll() {
        this.wait = true;
        const readSize = this.txtSizePage * 3;
        const readOffset = Math.max(0, this.allSize - readSize);

        this.currentFileOffset = readOffset;

        this.readFileText(readOffset, (str, bytesRead) => {
            if (this.page1) this.page1.text = null;
            if (this.page2) this.page2.text = null;
            this.page2 = null;
            
            this.page1 = { text: str, offset: readOffset, length: bytesRead };
            this.isAtChapterEnd = true;
            this.isAtChapterStart = (readOffset === 0);
            
            setTimeout(() => {
                this.$element("contentContainer").getBoundingClientRect({
                    success: (rect) => {
                        this.contentHeight = rect.height;
                        const scrollPos = this.contentHeight - this.scrollHeight;
                        this.scrollTopValue = scrollPos > 0 ? scrollPos : 0;
                        this.currentScrollTop = this.scrollTopValue;
                        this.wait = false;
                        this.updateChapterProgress();
                        this.saveData(true);
                    },
                    fail: () => { this.wait = false; }
                });
            }, 150);
        });
    },
	goToNextChapter() {
		if (this.wait) return;
		this.wait = true;
	
		const nextChapterIndex = this.currentChapterIndexInAll + 1;
		if (nextChapterIndex >= this.totalChapters) {
			prompt.showToast({ message: '已是最后一章' });
			if (this.autoInterval) {
				clearInterval(this.autoInterval);
				this.autoInterval = null;
				prompt.showToast({ message: '已关闭自动翻页' });
				if (!this.isKeepScreenOn) {
					brightness.setKeepScreenOn({ keepScreenOn: false });
				}
			}
			this.wait = false;
			return;
		}
		
		this.isAtChapterEnd = false;
		this.currentFileOffset = 0;
		this.savedScrollOffset = 0;
		this.scrollTopValue = 0;
		this.currentScrollTop = 0;
		
		this.loadChapter(nextChapterIndex, () => {
			if (this.readMode === 'nostalgic') {
				this.loadNostalgicChapter(0);
			} else {
				this.page1 = { text: "加载中...", offset: 0, length: 0 };
				this.page2 = null;
				this.loadInitialSegments();
				this.isAtChapterStart = false;
				this.isNearTopForHd = true;
			}
			this.chapterProgress = 0;
			this.saveData(true);
		});
	},
	saveData(forceImmediate = false){
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (forceImmediate) {
			
			this._performSave();
		} else {
			
			if (this.saveMode === 'periodic' && this.saveIntervalValue > 0) {
				this.saveDataTimeout = setTimeout(() => {
					this._performSave();
					this.saveDataTimeout = null;
				}, this.saveIntervalValue * 1000);
			}
			
		}
	},
	async _performSave() {
		if (!this.name || this.totalChapters === 0) return;
		try {
			let progress = await bookStorage.get(this.name);
			
			progress.chapterIndex = this.currentChapterIndexInAll;
			
			if (this.readMode === 'nostalgic') {
				if (this.nostalgicPageIndex >= 0 && this.nostalgicPages.length > 0) {
					const charOffset = this.nostalgicPageIndex * this.nostalgicCharsPerPage;
					progress.offsetInChapter = Math.max(0, charOffset * 2);
					progress.scrollOffset = 0;
				} else {
					progress.offsetInChapter = 0;
					progress.scrollOffset = 0;
				}
			} else {
				progress.offsetInChapter = Math.max(0, Math.floor(this.currentFileOffset || 0));
				progress.scrollOffset = Math.max(0, Math.floor(this.currentScrollTop || 0));
			}
			
			progress.txtSizePage = this.txtSizePage;
			progress.fontSize = this.fontSize;
			progress.lastReadTimestamp = Date.now();
			
			await bookStorage.set(this.name, progress);
			progress = null;
		} catch (e) {
			
		}
	},
	async onHide(){
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.autoInterval) { 
			clearInterval(this.autoInterval); 
			this.autoInterval = null; 
		}
		
		
		try {
			await this._performSave();
		} catch (e) {
			
		}
		
		brightness.setKeepScreenOn({ keepScreenOn: false }); 
	},
	async onDestroy(){ 
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.timer) {
			clearInterval(this.timer); 
			this.timer = null;
		}
		if (this.autoInterval) { 
			clearInterval(this.autoInterval); 
			this.autoInterval = null; 
		} 
		if (this.clickTimeout) {
			clearTimeout(this.clickTimeout);
			this.clickTimeout = null;
		}
		if (this.gestureClickTimeout) {
			clearTimeout(this.gestureClickTimeout);
			this.gestureClickTimeout = null;
		}
		if (this.longPressTimeout) {
			clearTimeout(this.longPressTimeout);
			this.longPressTimeout = null;
		}
		
		
		try {
			await this._performSave();
		} catch (e) {
			
		}
		
		this.page1 = null;
		this.page2 = null;
		
		brightness.setKeepScreenOn({ keepScreenOn: false }); 

		if (typeof global !== 'undefined' && typeof global.runGC === 'function') {
			global.runGC();
		}
	},
	onBackPress(){ this.back(); return true; },
	async back(){
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.clickTimeout) {
			clearTimeout(this.clickTimeout);
			this.clickTimeout = null;
		}
		if (this.gestureClickTimeout) {
			clearTimeout(this.gestureClickTimeout);
			this.gestureClickTimeout = null;
		}
		if (this.longPressTimeout) {
			clearTimeout(this.longPressTimeout);
			this.longPressTimeout = null;
		}
		if (this.autoInterval) { 
			clearInterval(this.autoInterval); 
			this.autoInterval = null; 
		}
		
		
		try {
			await this._performSave();
		} catch (e) {
			
		}
		
		router.back();
	},
	gotoSetting(){
		if (this.isProcessingClick) return;
		this.isProcessingClick = true;
		this.saveData(true);
		globalThis.isKeepScreenOn = this.isKeepScreenOn;
		router.push({
			uri: '/pages/detailsetting',
			params: { name: this.name }
		});
		setTimeout(() => { this.isProcessingClick = false; }, 500);
	},
	async exitAppForTeacherScreen() {
		
		if (this.saveDataTimeout) {
			clearTimeout(this.saveDataTimeout);
			this.saveDataTimeout = null;
		}
		if (this.autoInterval) {
			clearInterval(this.autoInterval);
			this.autoInterval = null;
		}
		
		
		try {
			await this._performSave();
		} catch (e) {
			
		}
		
		app.terminate();
	},
	loadNostalgicChapter(offsetInChapter) {
		if (!this.nostalgicFullContent) {
			this.nostalgicPageText = "加载中...";
			this.nostalgicPages = [];
			this.nostalgicPageIndex = 0;
			this.wait = false;
			return;
		}
		
		this.calculateNostalgicCharsPerPage();
		this.splitNostalgicContent();
		
		if (offsetInChapter === -1) {
			this.nostalgicPageIndex = Math.max(0, this.nostalgicPages.length - 1);
		} else if (offsetInChapter > 0 && this.nostalgicFullContent.length > 0 && this.nostalgicCharsPerPage > 0) {
			const charOffset = offsetInChapter / 2;
			const targetPageIndex = Math.floor(charOffset / this.nostalgicCharsPerPage);
			this.nostalgicPageIndex = Math.min(targetPageIndex, Math.max(0, this.nostalgicPages.length - 1));
		} else {
			this.nostalgicPageIndex = 0;
		}
		
		this.updateNostalgicPage();
		this.isAtChapterStart = this.nostalgicPageIndex === 0;
		this.isAtChapterEnd = this.nostalgicPageIndex >= this.nostalgicPages.length - 1;
		this.isNearTopForHd = this.nostalgicPageIndex === 0;
		this.updateChapterProgress();
		this.wait = false;
	},
	splitNostalgicContent() {
		if (!this.nostalgicFullContent || this.nostalgicCharsPerPage <= 0) {
			this.nostalgicPages = [];
			return;
		}
		
		const pages = [];
		let start = 0;
		const screenWidth = 432;
		const screenHeight = this.scrollHeight;
		const linesPerPage = Math.floor(screenHeight / this.lineHeight);
		const charsPerLine = Math.floor(screenWidth / this.fontSize);
		
		if (linesPerPage <= 0 || charsPerLine <= 0) {
			if (this.nostalgicFullContent.length > 0) {
				this.nostalgicPages = [this.nostalgicFullContent];
			} else {
				this.nostalgicPages = [];
			}
			return;
		}
		
		while (start < this.nostalgicFullContent.length) {
			let currentLine = 0;
			let currentLineChars = 0;
			let end = start;
			
			while (end < this.nostalgicFullContent.length && currentLine < linesPerPage) {
				const char = this.nostalgicFullContent[end];
				
				if (char === '\n') {
					currentLine++;
					currentLineChars = 0;
					end++;
				} else {
					currentLineChars++;
					if (currentLineChars >= charsPerLine) {
						currentLine++;
						currentLineChars = 0;
					}
					end++;
				}
			}
			
			if (end > this.nostalgicFullContent.length) {
				end = this.nostalgicFullContent.length;
			}
			
			if (this.preventParagraphSplitting && end < this.nostalgicFullContent.length) {
				const lastNewline = this.nostalgicFullContent.lastIndexOf('\n', end);
				if (lastNewline > start) {
					end = lastNewline + 1;
				}
			}
			
			if (end <= start) {
				end = Math.min(start + this.nostalgicCharsPerPage, this.nostalgicFullContent.length);
			}
			
			const pageText = this.nostalgicFullContent.substring(start, end);
			
			if (pageText.length > 0) {
				pages.push(pageText);
			} else {
				break;
			}
			
			start = end;
		}
		
		if (pages.length === 0 && this.nostalgicFullContent.length > 0) {
			pages.push(this.nostalgicFullContent);
		}
		
		this.nostalgicPages = pages;
	},
	updateNostalgicPage() {
		if (this.nostalgicPages.length === 0) {
			this.nostalgicPageText = "";
			return;
		}
		
		if (this.nostalgicPageIndex < 0) {
			this.nostalgicPageIndex = 0;
		}
		if (this.nostalgicPageIndex >= this.nostalgicPages.length) {
			this.nostalgicPageIndex = this.nostalgicPages.length - 1;
		}
		
		this.nostalgicPageText = this.nostalgicPages[this.nostalgicPageIndex] || "";
		this.isAtChapterStart = this.nostalgicPageIndex === 0;
		this.isAtChapterEnd = this.nostalgicPageIndex >= this.nostalgicPages.length - 1;
		this.updateChapterProgress();
		this.saveData(true);
	},
	onNostalgicClick(event) {
		if (this.wait) return;

		if (this.teacherScreenEnabled) {
			this.clickCount++;
			if (this.clickTimeout) {
				clearTimeout(this.clickTimeout);
			}

			if (this.clickCount >= 3) {
				this.clickCount = 0;
				clearTimeout(this.clickTimeout);
				this.clickTimeout = null;
				this.exitAppForTeacherScreen();
				return;
			}

			this.clickTimeout = setTimeout(() => {
				this.clickCount = 0;
				this.clickTimeout = null;
			}, 500);
		}

		const handleUIToggle = () => {
			this.showSetting = !this.showSetting;
		}

		if (this.gestureMode === 'double') {
			this.gestureClickCount++;
			if (this.gestureClickTimeout) {
				clearTimeout(this.gestureClickTimeout);
				this.gestureClickTimeout = null;
			}
			if (this.gestureClickCount === 2) {
				this.gestureClickCount = 0;
				this.gestureClickTimeout = null;
				handleUIToggle();
			} else {
				this.gestureClickTimeout = setTimeout(() => {
					this.gestureClickCount = 0;
					this.gestureClickTimeout = null;
					if (!this.showSetting) {
						const clickY = event.offsetY || (event.detail && event.detail.y) || 0;
						const containerHeight = this.scrollHeight;
						const topThird = containerHeight / 3;
						const bottomThird = containerHeight * 2 / 3;
						
						if (clickY < topThird) {
							if (this.isAtChapterStart && this.currentChapterIndexInAll > 0) {
								this.goToPrevChapter();
							} else {
								this.nostalgicPrevPage();
							}
						} else if (clickY > bottomThird) {
							if (this.isAtChapterEnd && this.currentChapterIndexInAll < this.totalChapters - 1) {
								this.goToNextChapter();
							} else {
								this.nostalgicNextPage();
							}
						}
					}
				}, 300);
			}
		} else {
			if (this.showSetting) {
				handleUIToggle();
			} else {
				const clickY = event.offsetY || (event.detail && event.detail.y) || 0;
				const containerHeight = this.scrollHeight;
				const topThird = containerHeight / 3;
				const bottomThird = containerHeight * 2 / 3;
				
				if (clickY < topThird) {
					if (this.isAtChapterStart && this.currentChapterIndexInAll > 0) {
						this.goToPrevChapter();
					} else {
						this.nostalgicPrevPage();
					}
				} else if (clickY > bottomThird) {
					if (this.isAtChapterEnd && this.currentChapterIndexInAll < this.totalChapters - 1) {
						this.goToNextChapter();
					} else {
						this.nostalgicNextPage();
					}
				} else {
					handleUIToggle();
				}
			}
		}
	},
	nostalgicNextPage() {
		if (this.nostalgicPageIndex < this.nostalgicPages.length - 1) {
			this.nostalgicPageIndex++;
			this.updateNostalgicPage();
		} else {
			// 确保 isAtChapterEnd 被正确设置
			this.isAtChapterEnd = true;
		}
	},
	nostalgicPrevPage() {
		if (this.nostalgicPageIndex > 0) {
			this.nostalgicPageIndex--;
			this.updateNostalgicPage();
		}
	},
  	onTxtClick(event) {
		if (this.wait) return;

		if (this.teacherScreenEnabled) {
			this.clickCount++;
			if (this.clickTimeout) {
				clearTimeout(this.clickTimeout);
			}

			if (this.clickCount >= 3) {
				this.clickCount = 0;
				clearTimeout(this.clickTimeout);
				this.clickTimeout = null;
				this.exitAppForTeacherScreen();
				return;
			}

			this.clickTimeout = setTimeout(() => {
				this.clickCount = 0;
				this.clickTimeout = null;
			}, 500);
		}

		const handleUIToggle = () => {
			this.showSetting = !this.showSetting;
		}

		if (this.gestureMode === 'double') {
			this.gestureClickCount++;
			if (this.gestureClickTimeout) {
				clearTimeout(this.gestureClickTimeout);
				this.gestureClickTimeout = null;
			}
			if (this.gestureClickCount === 2) {
				this.gestureClickCount = 0;
				this.gestureClickTimeout = null;
				handleUIToggle();
			} else {
				this.gestureClickTimeout = setTimeout(() => {
					this.gestureClickCount = 0;
					this.gestureClickTimeout = null;
					if (this.swipe !== 'column') {
						if (this.showSetting) {
							this.showSetting = false;
						} else {
							if (event.offsetY <= 158) { this.lastPage(); }
							else if (event.offsetY > 322) { this.nextPage(); }
						}
					}
				}, 300);
			}
		} else { 
			if (this.swipe === 'column') {
				handleUIToggle();
			} else {
				if (this.showSetting) {
					handleUIToggle();
				} else {
					if (event.offsetY <= 158) { this.lastPage(); }
					else if (event.offsetY <= 322) { handleUIToggle(); }
					else { this.nextPage(); }
				}
			}
		}
	},
		onTxtLongPress(event) {
  		if (this.auto) {
			if(this.autoInterval){ clearInterval(this.autoInterval); this.autoInterval = null; prompt.showToast({ message: '已关闭自动翻页' }); if (!this.isKeepScreenOn) { brightness.setKeepScreenOn({ keepScreenOn: false }); } return; }
			this.autoInterval = setInterval(() => {
				if (this.wait) return; // 如果正在加载，跳过本次翻页
				if (this.readMode === 'nostalgic') {
					if (this.isAtChapterEnd) {
						this.goToNextChapter();
					} else {
						this.nostalgicNextPage();
					}
				} else {
					if (this.isAtChapterEnd) {
						this.goToNextChapter();
					} else {
						this.nextPage();
					}
				}
			}, this.auto*1000);
			prompt.showToast({ message: '已开启自动翻页' });
			brightness.setKeepScreenOn({ keepScreenOn: true });
		}
	},
	lastPage() { this.$element("scrollId").scrollBy({ top: - (this.pageHeigh * (this.autoReadDistance / 100)), behavior: 'smooth' }); },
  	nextPage() { this.$element("scrollId").scrollBy({ top: (this.pageHeigh * (this.autoReadDistance / 100)), behavior: 'smooth' }); },
	toggleKeepScreenOn() { this.isKeepScreenOn = !this.isKeepScreenOn; brightness.setKeepScreenOn({ keepScreenOn: this.isKeepScreenOn }); prompt.showToast({ message: this.isKeepScreenOn ? '已开启屏幕常亮' : '已关闭屏幕常亮' }); },
	async addBookmark() {
		if (this.isProcessingClick) return;
		this.isProcessingClick = true;

		if (this.longPressTriggered) {
			this.isProcessingClick = false;
			return;
		}

		if (this.readMode === 'nostalgic') {
            prompt.showToast({ message: '怀旧模式不支持' });
			return;
		}
		
		
		let bookmarks = await bookStorage.getBookmarks(this.name);
		if (!bookmarks) { bookmarks = []; }
		
		const chapter = await chapterManager.getChapterByIndex(this.name, this.currentChapterIndexInAll);
        if (!chapter || chapter.index === undefined) {
            prompt.showToast({ message: '无法添加书签，章节信息错误' });
			this.isProcessingClick = false;
            return;
        }

		const chapterIndex = chapter.index;
		const newBookmark = { 
			chapterIndex: chapterIndex,
			chapterName: this.currentChapterName,
			
			offsetInChapter: Math.max(0, Math.floor(this.currentFileOffset || 0)), 
			scrollOffset: Math.max(0, Math.floor(this.currentScrollTop || 0)), 
			time: new Date().getTime(), 
			name: `书签${bookmarks.length + 1}` 
		};

		bookmarks.push(newBookmark);
		bookmarks.sort((a, b) => a.chapterIndex - b.chapterIndex || a.offsetInChapter - b.offsetInChapter);
		
		try {
			await bookStorage.setBookmarks(this.name, bookmarks);
			prompt.showToast({ message: '添加书签成功' });
		} catch (e) {
			prompt.showToast({ message: '添加书签失败' });
		}
		bookmarks = null;
		this.isProcessingClick = false;
	},
	gotoBookmarks() { 
		if (this.isProcessingClick) return;
		this.isProcessingClick = true;

		this.longPressTriggered = true;
		if (this.longPressTimeout) {
			clearTimeout(this.longPressTimeout);
		}
		this.longPressTimeout = setTimeout(() => {
			this.longPressTriggered = false;
			this.longPressTimeout = null;
		}, 300);
		this.saveData(true); 
		router.push({ uri: '/pages/bookmarks', params: { name: this.name } }); 
		setTimeout(() => { this.isProcessingClick = false; }, 500);
	},
	async updateChapterProgress() {
		if (!this.showProgressBar) {
			this.chapterProgress = 0;
			return;
		}

		if (this.isAtChapterEnd) {
			this.chapterProgress = 100;
			return;
		}

		if (this.readMode === 'nostalgic') {
			if (this.nostalgicPages.length > 0 && this.nostalgicPageIndex >= 0) {
				const progress = ((this.nostalgicPageIndex + 1) / this.nostalgicPages.length) * 100;
				this.chapterProgress = Math.min(100, Math.max(0, progress || 0));
			} else {
				this.chapterProgress = 0;
			}
		} else {
			if (this.allSize > 0) {
				let totalScrolledBytes = this.currentFileOffset;
				if (this.contentHeight > 0) {
					const loadedContentBytes = this.page1.length + (this.page2 ? this.page2.length : 0);
					const bytesPerPixel = loadedContentBytes / this.contentHeight;
					totalScrolledBytes += this.currentScrollTop * bytesPerPixel;
				}
				const progress = (totalScrolledBytes / this.allSize) * 100;
				this.chapterProgress = Math.min(100, Math.max(0, progress || 0));
			} else {
				this.chapterProgress = 0;
			}
		}
	}
	}
  </script>

<style>
.page {
	width: 432px;
	height: 514px;
	background-color: #000000;
}
.progress-bar-container {
	position: absolute;
	bottom: 0px;
	width: 432px;
	justify-content: center;
	align-items: center;
}
.progress-bar-percent {
	position: absolute;
	left: 0px;
	width: 432px;
	text-align: center;
	color: rgba(255, 255, 255, 0.6);
	font-size: 20px;
	font-weight: bold;
}
</style>